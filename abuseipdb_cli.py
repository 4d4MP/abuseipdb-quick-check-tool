#!/usr/bin/env python3
"""
AbuseIPDB Quick Check Tool
==========================

This command-line utility queries the AbuseIPDB API to assess IP addresses for abuse
activity. It supports interactive entry of IPs or reading from a CSV file, runs
up to ten API requests concurrently, and presents results either as a formatted
table on the console or writes them to a CSV file. Optional flags allow
filtering out non‑high‑confidence entries.

Usage:
    python abuseipdb_cli.py                          # interactive prompt for IPs
    python abuseipdb_cli.py -i ips.csv               # read IPs from a CSV file
    python abuseipdb_cli.py -i ips.csv -o out.csv    # write results to a CSV file
    python abuseipdb_cli.py -i ips.csv -x            # exclude confidence < 100

The tool will ask for your AbuseIPDB API key on first run unless the help
flag (-h/--help) is specified. Use the `-h` or `--help` flag to see full
options without prompting for the API key.

Author: Generated by OpenAI's Assistant
License: Apache License 2.0
"""

import argparse
import csv
import getpass
import os
import re
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import partial

import requests


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description=(
            "AbuseIPDB Quick Check Tool with parallel requests and CSV I/O."
        ),
        epilog=(
            "Examples:\n"
            "  python abuseipdb_cli.py\n"
            "  python abuseipdb_cli.py -i ips.csv\n"
            "  python abuseipdb_cli.py -i ips.csv -o out.csv\n"
            "  python abuseipdb_cli.py -i ips.csv -o out.csv -x\n"
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "-i",
        "--input-file",
        help="Path to a CSV file containing one IP address per line.",
    )
    parser.add_argument(
        "-o",
        "--output-file",
        help="Path to a CSV file to write results instead of printing them.",
    )
    parser.add_argument(
        "-x",
        "--exclude",
        action="store_true",
        help="Exclude results with an abuseConfidenceScore less than 100.",
    )
    return parser.parse_args()


HEADERS = [
    "ipAddress",
    "abuseConfidenceScore",
    "totalReports",
    "domain",
    "countryCode",
    "usageType",
    "isTor",
]


def get_api_key() -> str:
    """Prompt the user for an API key using getpass."""
    return getpass.getpass("Enter your AbuseIPDB API key: ")


def read_ips_from_csv(path: str) -> list[str]:
    """Read IP addresses from a CSV file (one per line).

    Args:
        path: Relative or absolute path to CSV file.

    Returns:
        A list of non-empty IP strings.
    """
    ips: list[str] = []
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                ip = line.strip().strip("'\"")
                if ip:
                    ips.append(ip)
    except OSError as e:
        print(f"Could not read CSV file '{path}': {e}")
        return []
    return ips


def get_ip_list_from_prompt() -> list[str]:
    """Prompt the user for IP addresses separated by commas or semicolons."""
    ip_input = input(
        "Enter IPs (comma/semicolon-separated). Empty input exits:\n> "
    ).strip()
    if not ip_input:
        return []
    ip_list = re.split(r"[;,]", ip_input)
    return [ip.strip("'\"").strip() for ip in ip_list if ip.strip("'\"").strip()]


def print_table(ip_results: list[dict]):
    """Print results as a formatted table on the console."""
    print("\n\n")
    # calculate dynamic widths (minimum width of 20)
    column_widths = {h: max(len(h), 20) for h in HEADERS}
    for result in ip_results:
        for h in HEADERS:
            column_widths[h] = max(column_widths[h], len(str(result.get(h, "N/A"))))

    separator = "+" + "+".join("-" * (column_widths[h] + 2) for h in HEADERS) + "+"
    header_row = "| " + " | ".join(
        h.ljust(column_widths[h]) for h in HEADERS
    ) + " |"

    print(separator)
    print(header_row)
    print(separator)

    for result in ip_results:
        row = "| " + " | ".join(
            str(result.get(h, "N/A")).ljust(column_widths[h]) for h in HEADERS
        ) + " |"
        print(row)
        print(separator)


def write_csv(path: str, rows: list[dict]):
    """Write results to a CSV file.

    Args:
        path: Destination file path.
        rows: List of dictionaries containing results.
    """
    try:
        with open(path, "w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=HEADERS)
            writer.writeheader()
            for r in rows:
                writer.writerow({k: r.get(k, "N/A") for k in HEADERS})
        print(f"Wrote {len(rows)} rows to '{path}'.")
    except OSError as e:
        print(f"Failed to write CSV '{path}': {e}")


def check_ip(session: requests.Session, api_key: str, ip: str) -> dict | None:
    """Query a single IP address via AbuseIPDB API and return result.

    This helper ensures the IP string is sanitised and catches common
    exceptions, returning error information in a structured format so that
    downstream code can uniformly display or store it.

    Args:
        session: A requests.Session reused across calls for connection pooling.
        api_key: User's AbuseIPDB API key.
        ip: IP address to query.

    Returns:
        A dictionary of result data, or None on invalid or empty input.
    """
    ip = ip.replace(",", "").replace(";", "").strip()
    if not ip:
        return None

    url = f"https://api.abuseipdb.com/api/v2/check?ipAddress={ip}"
    headers = {"Accept": "application/json", "Key": api_key}

    try:
        resp = session.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        data = resp.json().get("data", {})
        return data
    except requests.exceptions.HTTPError as http_err:
        return {
            "ipAddress": ip,
            "abuseConfidenceScore": "ERR",
            "totalReports": "-",
            "domain": f"HTTP error: {http_err}",
            "countryCode": "-",
            "usageType": "-",
            "isTor": "-",
        }
    except requests.exceptions.ConnectionError as ce:
        return {
            "ipAddress": ip,
            "abuseConfidenceScore": "ERR",
            "totalReports": "-",
            "domain": f"Connection error: {ce}",
            "countryCode": "-",
            "usageType": "-",
            "isTor": "-",
        }
    except requests.exceptions.Timeout:
        return {
            "ipAddress": ip,
            "abuseConfidenceScore": "ERR",
            "totalReports": "-",
            "domain": "Request timeout",
            "countryCode": "-",
            "usageType": "-",
            "isTor": "-",
        }
    except requests.exceptions.RequestException as err:
        return {
            "ipAddress": ip,
            "abuseConfidenceScore": "ERR",
            "totalReports": "-",
            "domain": f"Unexpected error: {err}",
            "countryCode": "-",
            "usageType": "-",
            "isTor": "-",
        }


def print_progress_bar(
    completed: int,
    total: int,
    prefix: str = "Progress",
    suffix: str = "",
    decimals: int = 1,
    length: int = 50,
    fill: str = "█",
) -> None:
    """Render a terminal progress bar.

    Args:
        completed: Number of completed items.
        total: Total number of items.
        prefix: Prefix text before the bar.
        suffix: Suffix text after the bar.
        decimals: Number of decimal places to show for percentage.
        length: Character length of the bar itself.
        fill: Bar fill character.
    """
    if total <= 0:
        return
    completed = min(completed, total)
    percent = f"{100 * (completed / float(total)):.{decimals}f}"
    filled_length = int(length * completed // total)
    bar = fill * filled_length + "-" * (length - filled_length)
    sys.stdout.write(f"\r{prefix} |{bar}| {percent}% {suffix}")
    sys.stdout.flush()
    if completed == total:
        sys.stdout.write("\n")
        sys.stdout.flush()


def fetch_results(ip_list: list[str], api_key: str) -> list[dict]:
    """Fetch results for a list of IP addresses concurrently.

    Uses a ThreadPoolExecutor to run up to ten API queries in parallel and
    preserves the order of results corresponding to the input order. A
    progress bar is displayed on the console as tasks complete.

    Args:
        ip_list: List of IP addresses to query.
        api_key: User's AbuseIPDB API key.

    Returns:
        A list of result dictionaries, preserving the original order.
    """
    total = len(ip_list)
    print_progress_bar(0, total)

    results_list: list[dict | None] = [None] * total

    with requests.Session() as session:
        with ThreadPoolExecutor(max_workers=10) as executor:
            worker = partial(check_ip, session, api_key)
            future_to_idx = {
                executor.submit(worker, ip): idx for idx, ip in enumerate(ip_list)
            }
            completed = 0
            for future in as_completed(future_to_idx):
                idx = future_to_idx[future]
                data = future.result()
                if data:
                    results_list[idx] = data
                completed += 1
                print_progress_bar(completed, total)

    return [r for r in results_list if r]


def apply_exclude_100(rows: list[dict], exclude_flag: bool) -> list[dict]:
    """Filter results based on confidence score if exclude flag is set."""
    if not exclude_flag:
        return rows

    def is_100(val: str | int | None) -> bool:
        try:
            return int(val) == 100
        except (ValueError, TypeError):
            return False

    return [r for r in rows if is_100(r.get("abuseConfidenceScore"))]


def main() -> None:
    args = parse_args()

    # If help flag used via argparse, the program exits before prompting for API key
    api_key = get_api_key()

    # If an input file is specified, run once and exit
    if args.input_file:
        if not os.path.isfile(args.input_file):
            print(f"Input file not found: {args.input_file}")
            sys.exit(1)
        ip_list = read_ips_from_csv(args.input_file)
        if not ip_list:
            print("No IPs found in input file. Exiting...")
            sys.exit(0)

        rows = fetch_results(ip_list, api_key)
        rows = apply_exclude_100(rows, args.exclude)
        if args.output_file:
            write_csv(args.output_file, rows)
        else:
            print_table(rows)
        return

    # Interactive mode: prompt repeatedly until user exits
    while True:
        ip_list = get_ip_list_from_prompt()
        if not ip_list:
            print("Exiting... Goodbye!")
            break
        rows = fetch_results(ip_list, api_key)
        rows = apply_exclude_100(rows, args.exclude)
        if args.output_file:
            write_csv(args.output_file, rows)
        else:
            print_table(rows)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nProcess interrupted. Exiting...")
        sys.exit(0)